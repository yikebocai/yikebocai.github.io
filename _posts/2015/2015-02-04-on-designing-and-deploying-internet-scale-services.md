---
layout: post
title: 可扩展互联网服务的设计和部署【译】
categories: tech
tags: 
- architecture
---

> 这篇译文源自当时还在微软`Windows Live Services Platform`部门的[James Hamilton](http://www.mvdirona.com/jrh/work/)的经典论文 [On Designing and Deploying Internet-Scale Services](https://www.usenix.org/legacy/event/lisa07/tech/full_papers/hamilton/hamilton_html/)，他现在是Amazon Web Services团队的成员之一，读了一遍感觉还有很多不够清晰，遂决定把它翻译成中文，以便更深入的了解。

## 概述

系统和管理员的比例通常作为一个大概指标来衡量高扩展服务的管理成本。对于规划较小很少有自动化的服务这个比率可能会低至`2：1`，但在领先并高度自动化的服务，这个比率可能高达`2500：1`。在微软的服务里，`Autopilot`常被称作Windows Live搜索团队成就高系统管理员比率后面的魔法。既然自动化管理如此重要，最重要的因素其实是服务自身。是服务高效到自动化？什么是我们通常称作的运维友好？运维友好的服务要求很少的人工介入，并且大部分复杂异常的检测和恢复不需要管理的介入。本论文总结了来自MSN和Windows Live在大规模服务多年的最佳实践。

## 介绍

本篇论文总结了设计和部署运维友好的服务的一系列最佳实践。这是一个快速变化的主题领域，因此，最佳实践的任何列表都可能随着时间而变化。我们的目标是帮助那些：

* 快速开发运维友好的服务，并且
* 避免因此非运维友好服务导致的凌晨被电话吵醒以及和不高兴的客户开会

该工作基于我们过于20年在高扩展数据中心软件系统和可扩展互联网服务的经验，大多数来自近期领导`Exchange Hosted Services`团队（当时，一个中等规模的服务有近700服务器和220万以上的用户）。我们也吸收了来自`Windows Live Search`，`Windows Live Mail`，`Exchange Hosted Services`，`Live Communications Server`，`Windows Live Address Book Clearing House（ABCH）`，`MSN Spaces`，`Xbox Live`，`Rackable Systems Engineering Team`，和`Messenger Operations`团队以及`Microseft Global Fuundation Services Operations`团队的经验。好几个上述的服务的用户量已经增长到超过2.5亿。本论文也严重依赖`Berkeley`在`Recovery Oriented Computing`以及`Standford`在`Crash-Only Software`方面所做的工作。

`Bill Hoffman`对本论文贡献了很多最佳实践，最下面这三个信条最值得放在前面来说：

* **期待失败（Expect failures）**。一个组件可能在任何时间都会崩溃或都停止。依赖的组件也可能在任何时间会失败或被停止。这可能是网络失败，磁盘空间不足。优雅地处理所有可能的失败。
* **保持事情简单（Keep things simple）**。复杂产生问题。简单的事情更容易做对。避免不必要的依赖。安装要简单。一个服务器失败不要影响数据中心的其它机器。
* **自动化一切事情（Automate Everything）**。人会制造错误。人需要休息。人会忘记事情。自动化过程是可测的，可固化的，因此会更可靠。如果可能尽量自动化。

这三个信条是下面讨论的主题。

## 建议

本文由十个部分组成，每一部分涵盖设计和部署运维友好的服务的一个方面。包括：整体服务设计；面向自动化和配置的设计；依赖管理；发布周期和测试；硬件选型和标准化；运维和容易规划；审核，监控和报警；优雅降级和准入控制；客户和出版沟通计划；客户自助服务。

### 整体应用设计（Overall Application Design）

我们一直相信80%的运维问题源自设计和部署，因此整体服务设计是本文中最大和最重要的部分。当系统失败时，一个自然的倾向是首先去看运维状况，因为它是问题实际发生的地方。大多数运维问题，既然源自设计和部署，那么最好就是这里解决它们。

贯穿下面章节的一个共识是：严格区分开发，测试和运维在服务的世界里不是最有效的方式。我们看到很多低成本管理服务的趋势是和开发、测试、运维团队紧密工作密切相关。

除了这里讨论的最佳服务设计实践之外，随后的章节，“面向自动化和配置的设计”，在服务设计上也在重要的影响。高效的自动化管理和配置通常仅在一个约束的服务模型里才能达成。这里有一个始终重复的主题：简单是高效运维的核心。在硬件选择，服务设计，和部署模型上的关联约束是减少管理成本和提升服务可用性的极大驱动力。

一些运维友好的基本准则在整体服务设计上有最大的影响：

* **面向失败的设计（Desing for failure）**。这是在开发由许多相互协作的组件组成的大型服务系统时的最核心概念。这些组件会出问题并且会不断地出问题。这些组件也不会总是独立地协作和失败。当服务扩展到1万台服务器和5万块硬盘以上时，每天都会发生多次问题。如果一个硬件故障需要立即有人工介入，这个服务就无法成低配的扩展和可靠。整个服务必须具备没有人工介入也能处理故障的能力。故障恢复必须是一个简单的路径，并且该路径必须经过不断的测试。Standford的`Armando Fox`曾经对测试故障最佳的办法是不要正常关闭服务有过争论。就要通过暴力让它失败。这个听起来有点违反直觉，但如果一个故障路径没有不断的被使用，当需要的时候它很可能无法工作。

* **冗余和故障恢复（Redundancy and fault recovery）**。大型主机模式是买一个非常巨大，非常昂贵的服务器。主机有冗余的电源供应，热切换的CPU，和在一个单一双路的系统内能够提供可观的I/O吞吐量的外部总线架构。这些系统显而易见的问题是它们的费用。并且即使所有成本高昂的工程师都在，它们也无法足够可靠。为了获得5个9的可靠性，冗余是必须的。即使在一个单系统部署上获得4个9的可靠性也很困难。这个概念在工业界相当容易理解，但依然经常看到有服务构建在脆弱的、非冗余的数据层上面。设计一个在任何时间任何系统都可能崩溃（或者服务当掉）但仍然能达到服务等级协议(SLA)的服务需要非常小心的工程师。能够完全接受这个设计准则的ACID测试如下：运维团队能够在任意时间没有先降低工作负载的情况下下掉服务中的任何一台服务器吗？如果是，这就是同步冗余（没有数据丢失），故障检测，和自动故障转移。作为一个设计办法，我们建议一个通常使用的办法来发现和纠正潜在的服务安全问题：安全威胁建模。在安全威胁建模中，我们考虑每一个可能的安全威胁，对每一个给给予足够的减缓。同样的办法能被用作故障恢复设计。由此文档化所有可想到的组件故障模式和混合情况。对于每一个故障，确保服务能继续运行，并且没有不可接受的服务质量损失，或者确定这个故障风险对特定的服务是可接受的（比如，在一个非常空间冗余服务中丢失所有数据）。非常反常的组合也许不太可能被充分地查明，确保系统能通过它们正常运行是不经济的。但当做此决定时要小心。当运行上千台服务器每天有上百万的机会可能产生组件故障时我们惊讶于非正常事件是多频繁的发生。罕见的组合会变得很平常。

* **商业硬件单元（Commodity hardware slice）**。所有的服务组件都会对应到商业硬件单元上。比如，轻存储的服务器会是全双工，2~4核的系统，一个启动盘，$1000~$2500范围内，重存储的服务器通常会用16到24个磁盘。最重要的观察如下：
  - 大规模的商业服务器集群比它们替换掉的小规模的大型服务器便宜多了，
  - 服务器性能会比I/O性能的增长快很多，为特定数量的磁盘使用一个更小但更平衡的系统，
  - 电力消耗会随着服务线性增长但和时钟频率呈立方，使用最高性能的服务器运行会更贵，并且
  - 一个小型服务器当机时对整体服务处理能力的影响比例也更小

* **单一版本软件（Single-version software）**。两个因素导致一些服务比大多数打包好的产品开发成本更低并且进行更快：
  - 软件只需要单一内部部署，并且
  - 对企业级产品来说不需要支持前一个版本十年。
单一版本软件相对来说更容易和一个客户服务集成，特别是免费提供的。但当销售基于订金的服务给非客户时它也是同等重要。当企业部署新版本时（特别地慢）他们于他们的软件提供商有显著的影响和完全的控制权。既然那么多的软件版本需要支持，这会提升它们的运营成本和支持成本。最经济的服务是不要给客户版本的控制权，仅支持一个版本。维持单一版本软件线要求：
  - 观注非产生重要用户体验改变的发布，并且
  - 乐于允许需要这个控制级别的客户要么内部托管或者切换到愿意提供对人员敏感的多版本支持的应用服务提供商

* **多租户（Multi-tenancy）**。多租户是指所有公司或终端用户的服务托管在同一个服务中不要做物理隔离，而单租户是在一个独立的集群中做用户分组的隔离。对多租户的争论和对单版本支持几乎是一样的，并且是基于提供基础的、构建在自动化和大规模可扩展的低成本服务。

总结一下，我们在上面提到的基本的设计准则和考虑点如下：

* 面向失败的设计，
* 实现冗余和故障恢复，
* 基本商业硬件，
* 支持单版本软件，
* 支持多租户


